<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OMCompilerDoxygen: Conservative Garbage Collector Porting Directions</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OMCompilerDoxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Conservative Garbage Collector Porting Directions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The collector is designed to be relatively easy to port, but is not portable code per se. The collector inherently has to perform operations, such as scanning the stack(s), that are not possible in portable <a class="el" href="../../dd/de0/class_c.html">C</a> code.</p>
<p>All of the following assumes that the collector is being ported to a byte-addressable 32- or 64-bit machine. Currently all successful ports to 64-bit machines involve LP64 targets. The code base includes some provisions for P64 targets (notably Win64), but that has not been tested. You are hereby discouraged from attempting a port to non-byte-addressable, or 8-bit, or 16-bit machines.</p>
<p>The difficulty of porting the collector varies greatly depending on the needed functionality. In the simplest case, only some small additions are needed for the <code>include/private/gcconfig.h</code> file. This is described in the following section. Later sections discuss some of the optional features, which typically involve more porting effort.</p>
<p>Note that the collector makes heavy use of <code>ifdef</code>s. Unlike some other software projects, we have concluded repeatedly that this is preferable to system dependent files, with code duplicated between the files. However, to keep this manageable, we do strongly believe in indenting <code>ifdef</code>s correctly (for historical reasons usually without the leading sharp sign). (Separate source files are of course fine if they do not result in code duplication.)</p>
<h2>Adding Platforms to gcconfig.h</h2>
<p>If neither thread support, nor tracing of dynamic library data is required, these are often the only changes you will need to make.</p>
<p>The <code>gcconfig.h</code> file consists of three sections:</p>
<ol type="1">
<li><a class="el" href="../../d8/d4f/class_a.html">A</a> section that defines GC-internal macros that identify the architecture (e.g. <code>IA64</code> or <code>I386</code>) and operating system (e.g. <code>LINUX</code> or <code>MSWIN32</code>). This is usually done by testing predefined macros. By defining our own macros instead of using the predefined ones directly, we can impose a bit more consistency, and somewhat isolate ourselves from compiler differences. It is relatively straightforward to add a new entry here. But please try to be consistent with the existing code. In particular, 64-bit variants of 32-bit architectures general are <em>not</em> treated as a new architecture. Instead we explicitly test for 64-bit-ness in the few places in which it matters. (The notable exception here is <code>I386</code> and <code>X86_64</code>. This is partially historical, and partially justified by the fact that there are arguably more substantial architecture and ABI differences here than for RISC variants.) On GNU-based systems, <code>cpp -dM empty_source_file.c</code> seems to generate a set of predefined macros. On some other systems, the "verbose" compiler option may do so, or the manual page may list them.</li>
<li><a class="el" href="../../d8/d4f/class_a.html">A</a> section that defines a small number of platform-specific macros, which are then used directly by the collector. For simple ports, this is where most of the effort is required. We describe the macros below. This section contains a subsection for each architecture (enclosed in a suitable <code>ifdef</code>. Each subsection usually contains some architecture-dependent defines, followed by several sets of OS-dependent defines, again enclosed in <code>ifdef</code>s.</li>
<li><a class="el" href="../../d8/d4f/class_a.html">A</a> section that fills in defaults for some macros left undefined in the preceding section, and defines some other macros that rarely need adjustment for new platforms. You will typically not have to touch these. If you are porting to an OS that was previously completely unsupported, it is likely that you will need to add another clause to the definition of <code>GET_MEM</code>.</li>
</ol>
<p>The following macros must be defined correctly for each architecture and operating system:</p>
<ul>
<li><code>MACH_TYPE</code> - Defined to a string that represents the machine architecture. Usually just the macro name used to identify the architecture, but enclosed in quotes.</li>
<li><code>OS_TYPE</code> - Defined to a string that represents the operating system name. Usually just the macro name used to identify the operating system, but enclosed in quotes.</li>
<li><code>CPP_WORDSZ</code> - The word size in bits as a constant suitable for preprocessor tests, i.e. without casts or <code>sizeof</code> expressions. Currently always defined as either 64 or 32. For platforms supporting both 32- and 64-bit ABIs, this should be conditionally defined depending on the current ABI. There is a default of 32.</li>
<li><code>ALIGNMENT</code> - Defined to be the largest <em>N</em> such that all pointer are guaranteed to be aligned on <em>N</em>-byte boundaries. Defining it to be <em>1</em> will always work, but perform poorly. For all modern 32-bit platforms, this is 4. For all modern 64-bit platforms, this is 8. Whether or not X86 qualifies as a modern architecture here is compiler- and OS-dependent.</li>
<li><code>DATASTART</code> - The beginning of the main data segment. The collector will trace all memory between <code>DATASTART</code> and <code>DATAEND</code> for root pointers. On some platforms, this can be defined to a constant address, though experience has shown that to be risky. Ideally the linker will define a symbol (e.g. <code>_data</code> whose address is the beginning of the data segment. Sometimes the value can be computed using the <code>GC_SysVGetDataStart</code> function. Not used if either the next macro is defined, or if dynamic loading is supported, and the dynamic loading support defines a function <code>GC_register_main_static_data</code> which returns false.</li>
<li><code>SEARCH_FOR_DATA_START</code> - If this is defined <code>DATASTART</code> will be defined to a dynamically computed value which is obtained by starting with the address of <code>_end</code> and walking backwards until non-addressable memory is found. This often works on Posix-like platforms. It makes it harder to debug client programs, since startup involves generating and catching a segmentation fault, which tends to confuse users.</li>
<li><code>DATAEND</code> - Set to the end of the main data segment. Defaults to <code>end</code>, where that is declared as an array. This works in some cases, since the linker introduces a suitable symbol.</li>
<li><code>DATASTART2</code>, <code>DATAEND2</code> - Some platforms have two discontiguous main data segments, e.g. for initialized and uninitialized data. If so, these two macros should be defined to the limits of the second main data segment.</li>
<li><code>STACK_GROWS_UP</code> - Should be defined if the stack (or thread stacks) grow towards higher addresses. (This appears to be true only on PA-RISC. If your architecture has more than one stack per thread, and is not supported yet, you will need to do more work. Grep for "IA64" in the source for an example.)</li>
<li><code>STACKBOTTOM</code> - Defined to be the cool end of the stack, which is usually the highest address in the stack. It must bound the region of the stack that contains pointers into the GC heap. <a class="el" href="../../d9/d07/struct_with.html">With</a> thread support, this must be the cold end of the main stack, which typically cannot be found in the same way as the other thread stacks. If this is not defined and none of the following three macros is defined, client code must explicitly set <code>GC_stackbottom</code> to an appropriate value before calling <code>GC_INIT</code> or any other <code>GC_</code> routine.</li>
<li><code>LINUX_STACKBOTTOM</code> - May be defined instead of <code>STACKBOTTOM</code>. If defined, then the cold end of the stack will be determined Currently we usually read it from <code>/proc</code>.</li>
<li><code>HEURISTIC1</code> - May be defined instead of <code>STACKBOTTOM</code>. <code>STACK_GRAN</code> should generally also be redefined. The cold end of the stack is determined by taking an address inside <code>GC_init</code>s frame, and rounding it up to the next multiple of <code>STACK_GRAN</code>. This works well if the stack base is always aligned to a large power of two. (<code>STACK_GRAN</code> is predefined to 0x1000000, which is rarely optimal.)</li>
<li><code>HEURISTIC2</code> - May be defined instead of <code>STACKBOTTOM</code>. The cold end of the stack is determined by taking an address inside <code>GC_init</code>s frame, incrementing it repeatedly in small steps (decrement if <code>STACK_GROWS_UP</code>), and reading the value at each location. We remember the value when the first Segmentation violation or Bus error is signaled, round that to the nearest plausible page boundary, and use that as the stack base.</li>
<li><code>DYNAMIC_LOADING</code> - Should be defined if <code>dyn_load.c</code> has been updated for this platform and tracing of dynamic library roots is supported.</li>
<li><code>MPROTECT_VDB</code>, <code>PROC_VDB</code> - May be defined if the corresponding <em>virtual dirty bit</em> implementation in <code>os_dep.c</code> is usable on this platform. This allows incremental/generational garbage collection. <code>MPROTECT_VDB</code> identifies modified pages by write protecting the heap and catching faults. <code>PROC_VDB</code> uses the /proc primitives to read dirty bits.</li>
<li><code>PREFETCH</code>, <code>GC_PREFETCH_FOR_WRITE</code> - The collector uses <code><a class="el" href="../../d0/de1/group__core.html#ga60f2ba147483699266fe5a0960703e0c">PREFETCH(x)</a></code> to preload the cache with the data at <em>x</em> address. This defaults to a no-op.</li>
<li><code>CLEAR_DOUBLE</code> - If <code>CLEAR_DOUBLE</code> is defined, then <code><a class="el" href="../../db/d8a/gcconfig_8h.html#a30e742bbf9ec25e77d65ec37360af269">CLEAR_DOUBLE(x)</a></code> is used as a fast way to clear the two words at <code>GC_malloc</code>-aligned address <em>x</em>. By default, word stores of 0 are used instead.</li>
<li><code>HEAP_START</code> - May be defined as the initial address hint for mmap-based allocation.</li>
</ul>
<h2>Additional requirements for a basic port</h2>
<p>In some cases, you may have to add additional platform-specific code to other files. <a class="el" href="../../d8/d4f/class_a.html">A</a> likely candidate is the implementation of <code>GC_with_callee_saves_pushed</code> in <code>mach_dep.c</code>. This ensure that register contents that the collector must trace from are copied to the stack. Typically this can be done portably, but on some platforms it may require assembly code, or just tweaking of conditional compilation tests.</p>
<p>For GC v7, if your platform supports <code>getcontext</code>, then defining the macro <code>UNIX_LIKE</code> for your OS in <code>gcconfig.h</code> (if it is not defined there yet) is likely to solve the problem. otherwise, if you are using gcc, <code>_builtin_unwind_init</code> will be used, and should work fine. If that is not applicable either, the implementation will try to use <code>setjmp</code>. This will work if your <code>setjmp</code> implementation saves all possibly pointer-valued registers into the buffer, as opposed to trying to unwind the stack at <code>longjmp</code> time. The <code>setjmp_test</code> test tries to determine this, but often does not get it right.</p>
<p>In GC v6.x versions of the collector, tracing of registers was more commonly handled with assembly code. In GC v7, this is generally to be avoided.</p>
<p>Most commonly <code>os_dep.c</code> will not require attention, but see below.</p>
<h2>Thread support</h2>
<p>Supporting threads requires that the collector be able to find and suspend all threads potentially accessing the garbage-collected heap, and locate any state associated with each thread that must be traced.</p>
<p>The functionality needed for thread support is generally implemented in one or more files specific to the particular thread interface. For example, somewhat portable pthread support is implemented in <code>pthread_support.c</code> and <code>pthread_stop_world.c</code>. The essential functionality consists of:</p>
<ul>
<li><code>GC_stop_world</code> - Stops all threads which may access the garbage collected heap, other than the caller;</li>
<li><code>GC_start_world</code> - Restart other threads;</li>
<li><code>GC_push_all_stacks</code> - Push the contents of all thread stacks (or, at least, of pointer-containing regions in the thread stacks) onto the mark stack.</li>
</ul>
<p>These very often require that the garbage collector maintain its own data structures to track active threads.</p>
<p>In addition, <code>LOCK</code> and <code>UNLOCK</code> must be implemented in <code>gc_locks.h</code>.</p>
<p>The easiest case is probably a new pthreads platform on which threads can be stopped with signals. In this case, the changes involve:</p>
<ol type="1">
<li>Introducing a suitable <code>GC_xxx_THREADS</code> macro, which should be automatically defined by <code>gc_config_macros.h</code> in the right cases. It should also result in a definition of <code>GC_PTHREADS</code>, as for the existing cases.</li>
<li>For GC v7, ensuring that the <code>atomic_ops</code> package at least minimally supports the platform. If incremental GC is needed, or if pthread locks do not perform adequately as the allocation lock, you will probably need to ensure that a sufficient <code>atomic_ops</code> port exists for the platform to provided an atomic test and set operation. The latest GC code can use GCC atomic intrinsics instead of <code>atomic_ops</code> package (see <code>include/private/gc_atomic_ops.h</code>).</li>
<li>Making any needed adjustments to <code>pthread_stop_world.c</code> and <code>pthread_support.c</code>. Ideally none should be needed. In fact, not all of this is as well standardized as one would like, and outright bugs requiring workarounds are common. Non-preemptive threads packages will probably require further work. Similarly thread-local allocation and parallel marking requires further work in <code>pthread_support.c</code>, and may require better <code>atomic_ops</code> support.</li>
</ol>
<h2>Dynamic library support</h2>
<p>So long as <code>DATASTART</code> and <code>DATAEND</code> are defined correctly, the collector will trace memory reachable from file scope or <code>static</code> variables defined as part of the main executable. This is sufficient if either the program is statically linked, or if pointers to the garbage-collected heap are never stored in non-stack variables defined in dynamic libraries.</p>
<p>If dynamic library data sections must also be traced, then:</p>
<ul>
<li><code>DYNAMIC_LOADING</code> must be defined in the appropriate section of <code>gcconfig.h</code>.</li>
<li>An appropriate versions of the functions <code>GC_register_dynamic_libraries</code> should be defined in <code>dyn_load.c</code>. This function should invoke <code>GC_cond_add_roots(_region_start, region_end_, TRUE)</code> on each dynamic library data section.</li>
</ul>
<p>Implementations that scan for writable data segments are error prone, particularly in the presence of threads. They frequently result in race conditions when threads exit and stacks disappear. They may also accidentally trace large regions of graphics memory, or mapped files. On at least one occasion they have been known to try to trace device memory that could not safely be read in the manner the GC wanted to read it.</p>
<p>It is usually safer to walk the dynamic linker data structure, especially if the linker exports an interface to do so. But beware of poorly documented locking behavior in this case.</p>
<h2>Incremental GC support</h2>
<p>For incremental and generational collection to work, <code>os_dep.c</code> must contain a suitable <em>virtual dirty bit</em> implementation, which allows the collector to track which heap pages (assumed to be a multiple of the collectors block size) have been written during a certain time interval. The collector provides several implementations, which might be adapted. The default (<code>DEFAULT_VDB</code>) is a placeholder which treats all pages as having been written. This ensures correctness, but renders incremental and generational collection essentially useless.</p>
<h2>Stack traces for debug support</h2>
<p>If stack traces in objects are need for debug support, <code>GC_dave_callers</code> and <code>GC_print_callers</code> must be implemented.</p>
<h2>Disclaimer</h2>
<p>This is an initial pass at porting guidelines. Some things have no doubt been overlooked. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
