<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OMCompilerDoxygen: Debugging Garbage Collector Related Problems</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OMCompilerDoxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Debugging Garbage Collector Related Problems </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page contains some hints on debugging issues specific to the Boehm-Demers-Weiser conservative garbage collector. It applies both to debugging issues in client code that manifest themselves as collector misbehavior, and to debugging the collector itself.</p>
<p>If you suspect a bug in the collector itself, it is strongly recommended that you try the latest collector release before proceeding.</p>
<h2>Bus Errors and Segmentation Violations</h2>
<p>If the fault occurred in <code>GC_find_limit</code>, or with incremental collection enabled, this is probably normal. The collector installs handlers to take care of these. You will not see these unless you are using a debugger. Your debugger <em>should</em> allow you to continue. It's often preferable to tell the debugger to ignore SIGBUS and SIGSEGV ("handle SIGSEGV SIGBUS nostop noprint" in gdb, "ignore SIGSEGV SIGBUS" in most versions of dbx) and set a breakpoint in <code>abort</code>. The collector will call abort if the signal had another cause, and there was not other handler previously installed.</p>
<p>We recommend debugging without incremental collection if possible. (This applies directly to UNIX systems. Debugging with incremental collection under win32 is worse. See README.win32.)</p>
<p>If the application generates an unhandled SIGSEGV or equivalent, it may often be easiest to set the environment variable <code>GC_LOOP_ON_ABORT</code>. On many platforms, this will cause the collector to loop in a handler when the SIGSEGV is encountered (or when the collector aborts for some other reason), and a debugger can then be attached to the looping process. This sidesteps common operating system problems related to incomplete core files for multi-threaded applications, etc.</p>
<h2>Other Signals</h2>
<p>On most platforms, the multi-threaded version of the collector needs one or two other signals for internal use by the collector in stopping threads. It is normally wise to tell the debugger to ignore these. On Linux, the collector currently uses SIGPWR and SIGXCPU by default.</p>
<h2>Warning Messages About Needing to Allocate Blacklisted Blocks</h2>
<p>The garbage collector generates warning messages of the form:</p>
<pre class="fragment">Needed to allocate blacklisted block at 0x...
</pre><p>or</p>
<pre class="fragment">Repeated allocation of very large block ...
</pre><p>when it needs to allocate a block at a location that it knows to be referenced by a false pointer. These false pointers can be either permanent (e.g. a static integer variable that never changes) or temporary. In the latter case, the warning is largely spurious, and the block will eventually be reclaimed normally. In the former case, the program will still run correctly, but the block will never be reclaimed. Unless the block is intended to be permanent, the warning indicates a memory leak.</p>
<ol type="1">
<li>Ignore these warnings while you are using GC_DEBUG. Some of the routines mentioned below don't have debugging equivalents. (Alternatively, write the missing routines and send them to me.)</li>
<li>Replace allocator calls that request large blocks with calls to <code>GC_malloc_ignore_off_page</code> or <code>GC_malloc_atomic_ignore_off_page</code>. You may want to set a breakpoint in <code>GC_default_warn_proc</code> to help you identify such calls. Make sure that a pointer to somewhere near the beginning of the resulting block is maintained in a (preferably volatile) variable as long as the block is needed.</li>
<li>If the large blocks are allocated with realloc, we suggest instead allocating them with something like the following. Note that the realloc size increment should be fairly large (e.g. a factor of 3/2) for this to exhibit reasonable performance. But we all know we should do that anyway.</li>
</ol>
<pre class="fragment">    void * big_realloc(void *p, size_t new_size) {
        size_t old_size = GC_size(p);
        void * result;
        if (new_size &lt;= 10000) return(GC_realloc(p, new_size));
        if (new_size &lt;= old_size) return(p);
        result = GC_malloc_ignore_off_page(new_size);
        if (result == 0) return(0);
        memcpy(result,p,old_size);
        GC_free(p);
        return(result);
    }
</pre><ol type="1">
<li>In the unlikely case that even relatively small object (&lt;20KB) allocations are triggering these warnings, then your address space contains lots of "bogus pointers", i.e. values that appear to be pointers but aren't. Usually this can be solved by using <code>GC_malloc_atomic</code> or the routines in <code>gc_typed.h</code> to allocate large pointer-free regions of bitmaps, etc. Sometimes the problem can be solved with trivial changes of encoding in certain values. It is possible, to identify the source of the bogus pointers by building the collector with <code>-DPRINT_BLACK_LIST</code>, which will cause it to print the "bogus pointers", along with their location.</li>
<li>If you get only a fixed number of these warnings, you are probably only introducing a bounded leak by ignoring them. If the data structures being allocated are intended to be permanent, then it is also safe to ignore them. The warnings can be turned off by calling <code>GC_set_warn_proc</code> with a procedure that ignores these warnings (e.g. by doing absolutely nothing).</li>
</ol>
<h2>The Collector References a Bad Address in GC_malloc</h2>
<p>This typically happens while the collector is trying to remove an entry from its free list, and the free list pointer is bad because the free list link in the last allocated object was bad.</p>
<p><a class="el" href="../../d9/d07/struct_with.html">With</a> &gt;99% probability, you wrote past the end of an allocated object. Try setting <code>GC_DEBUG</code> before including <code>gc.h</code> and allocating with <code>GC_MALLOC</code>. This will try to detect such overwrite errors.</p>
<h2>Unexpectedly Large Heap</h2>
<p>Unexpected heap growth can be due to one of the following:</p>
<ol type="1">
<li>Data structures that are being unintentionally retained. This is commonly caused by data structures that are no longer being used, but were not cleared, or by caches growing without bounds.</li>
<li>Pointer misidentification. The garbage collector is interpreting integers or other data as pointers and retaining the "referenced" objects. <a class="el" href="../../d8/d4f/class_a.html">A</a> common symptom is that <a class="el" href="../../d0/daa/gc_8h.html#a6de78734ee9e2d575abf6574ca977f26">GC_dump()</a> shows much of the heap as black-listed.</li>
<li>Heap fragmentation. This should never result in unbounded growth, but it may account for larger heaps. This is most commonly caused by allocation of large objects.</li>
<li>Per object overhead. This is usually a relatively minor effect, but it may be worth considering. If the collector recognizes interior pointers, object sizes are increased, so that one-past-the-end pointers are correctly recognized. The collector can be configured not to do this (<code>-DDONT_ADD_BYTE_AT_END</code>).</li>
</ol>
<p>The collector rounds up object sizes so the result fits well into the chunk size (<code>HBLKSIZE</code>, normally 4K on 32 bit machines, 8K on 64 bit machines) used by the collector. Thus it may be worth avoiding objects of size 2K + 1 (or 2K if a byte is being added at the end.) The last two cases can often be identified by looking at the output of a call to <code>GC_dump</code>. Among other things, it will print the list of free heap blocks, and a very brief description of all chunks in the heap, the object sizes they correspond to, and how many live objects were found in the chunk at the last collection.</p>
<p>Growing data structures can usually be identified by:</p>
<ol type="1">
<li>Building the collector with <code>-DKEEP_BACK_PTRS</code>,</li>
<li>Preferably using debugging allocation (defining <code>GC_DEBUG</code> before including <code>gc.h</code> and allocating with <code>GC_MALLOC</code>), so that objects will be identified by their allocation site,</li>
<li>Running the application long enough so that most of the heap is composed of "leaked" memory, and</li>
<li>Then calling <code>GC_generate_random_backtrace</code> from gc_backptr.h a few times to determine why some randomly sampled objects in the heap are being retained.</li>
</ol>
<p>The same technique can often be used to identify problems with false pointers, by noting whether the reference chains printed by <code>GC_generate_random_backtrace</code> involve any misidentified pointers. An alternate technique is to build the collector with <code>-DPRINT_BLACK_LIST</code> which will cause it to report values that are almost, but not quite, look like heap pointers. It is very likely that actual false pointers will come from similar sources.</p>
<p>In the unlikely case that false pointers are an issue, it can usually be resolved using one or more of the following techniques:</p>
<ol type="1">
<li>Use <code>GC_malloc_atomic</code> for objects containing no pointers. This is especially important for large arrays containing compressed data, pseudo-random numbers, and the like. It is also likely to improve GC performance, perhaps drastically so if the application is paging.</li>
<li>If you allocate large objects containing only one or two pointers at the beginning, either try the typed allocation primitives is<code>gc_typed.h</code>, or separate out the pointer-free component.</li>
<li>Consider using <code>GC_malloc_ignore_off_page</code> to allocate large objects. (See <code>gc.h</code> and above for details. Large means &gt;100K in most environments.)</li>
<li>If your heap size is larger than 100MB or so, build the collector with <code>-DLARGE_CONFIG</code>. This allows the collector to keep more precise black-list information.</li>
<li>If you are using heaps close to, or larger than, a gigabyte on a 32-bit machine, you may want to consider moving to a platform with 64-bit pointers. This is very likely to resolve any false pointer issues.</li>
</ol>
<h2>Prematurely Reclaimed Objects</h2>
<p>The usual symptom of this is a segmentation fault, or an obviously overwritten value in a heap object. This should, of course, be impossible. In practice, it may happen for reasons like the following:</p>
<ol type="1">
<li>The collector did not intercept the creation of threads correctly in a multi-threaded application, e.g. because the client called <code>pthread_create</code> without including <code>gc.h</code>, which redefines it.</li>
<li>The last pointer to an object in the garbage collected heap was stored somewhere were the collector could not see it, e.g. in an object allocated with system <code>malloc</code>, in certain types of <code>mmap</code>ed files, or in some data structure visible only to the OS. (On some platforms, thread-local storage is one of these.)</li>
<li>The last pointer to an object was somehow disguised, e.g. by XORing it with another pointer.</li>
<li>Incorrect use of <code>GC_malloc_atomic</code> or typed allocation.</li>
<li>An incorrect <code>GC_free</code> call.</li>
<li>The client program overwrote an internal garbage collector data structure.</li>
<li><a class="el" href="../../d8/d4f/class_a.html">A</a> garbage collector bug.</li>
<li>(Empirically less likely than any of the above.) <a class="el" href="../../d8/d4f/class_a.html">A</a> compiler optimization that disguised the last pointer.</li>
</ol>
<p>The following relatively simple techniques should be tried first to narrow down the problem:</p>
<ol type="1">
<li>If you are using the incremental collector try turning it off for debugging.</li>
<li>If you are using shared libraries, try linking statically. If that works, ensure that DYNAMIC_LOADING is defined on your platform.</li>
<li>Try to reproduce the problem with fully debuggable unoptimized code. This will eliminate the last possibility, as well as making debugging easier.</li>
<li>Try replacing any suspect typed allocation and <code>GC_malloc_atomic</code> calls with calls to <code>GC_malloc</code>.</li>
<li>Try removing any <code>GC_free</code> calls (e.g. with a suitable <code>#define</code>).</li>
<li>Rebuild the collector with <code>-DGC_ASSERTIONS</code>.</li>
<li>If the following works on your platform (i.e. if gctest still works if you do this), try building the collector with <code>-DREDIRECT_MALLOC=GC_malloc_uncollectable</code>. This will cause the collector to scan memory allocated with malloc.</li>
</ol>
<p>If all else fails, you will have to attack this with a debugger. The suggested steps are:</p>
<ol type="1">
<li>Call <code>GC_dump</code> from the debugger around the time of the failure. Verify that the collectors idea of the root set (i.e. static data regions which it should scan for pointers) looks plausible. If not, i.e. if it does not include some static variables, report this as a collector bug. Be sure to describe your platform precisely, since this sort of problem is nearly always very platform dependent.</li>
<li>Especially if the failure is not deterministic, try to isolate it to a relatively small test case.</li>
<li>Set a break point in <code>GC_finish_collection</code>. This is a good point to examine what has been marked, i.e. found reachable, by the collector.</li>
<li>If the failure is deterministic, run the process up to the last collection before the failure. Note that the variable <code>GC_gc_no</code> counts collections and can be used to set a conditional breakpoint in the right one. It is incremented just before the call to <code>GC_finish_collection</code>. If object <code>p</code> was prematurely recycled, it may be helpful to look at <code>*GC_find_header(p)</code> at the failure point. The <code>hb_last_reclaimed</code> field will identify the collection number during which its block was last swept.</li>
<li>Verify that the offending object still has its correct contents at this point. Then call <code>GC_is_marked(p)</code> from the debugger to verify that the object has not been marked, and is about to be reclaimed. Note that <code>GC_is_marked(p)</code> expects the real address of an object (the address of the debug header if there is one), and thus it may be more appropriate to call <code>GC_is_marked(GC_base(p))</code> instead.</li>
<li>Determine a path from a root, i.e. static variable, stack, or register variable, to the reclaimed object. Call <code>GC_is_marked(q)</code> for each object <code>q</code> along the path, trying to locate the first unmarked object, say <code>r</code>.</li>
<li>If <code>r</code> is pointed to by a static root, verify that the location pointing to it is part of the root set printed by <code>GC_dump</code>. If it is on the stack in the main (or only) thread, verify that <code>GC_stackbottom</code> is set correctly to the base of the stack. If it is in another thread stack, check the collector's thread data structure (<code>GC_thread[]</code> on several platforms) to make sure that stack bounds are set correctly.</li>
<li>If <code>r</code> is pointed to by heap object <code>s</code>, check that the collector's layout description for <code>s</code> is such that the pointer field will be scanned. Call <code>*GC_find_header(s)</code> to look at the descriptor for the heap chunk. The <code>hb_descr</code> field specifies the layout of objects in that chunk. See <code>gc_mark.h</code> for the meaning of the descriptor. (If its low order 2 bits are zero, then it is just the length of the object prefix to be scanned. This form is always used for objects allocated with <code>GC_malloc</code> or <code>GC_malloc_atomic</code>.)</li>
<li>If the failure is not deterministic, you may still be able to apply some of the above technique at the point of failure. But remember that objects allocated since the last collection will not have been marked, even if the collector is functioning properly. On some platforms, the collector can be configured to save call chains in objects for debugging. Enabling this feature will also cause it to save the call stack at the point of the last GC in <code>GC_arrays._last_stack</code>.</li>
<li>When looking at GC internal data structures remember that a number of <code>GC_xxx</code> variables are really macro defined to <code>GC_arrays._xxx</code>, so that the collector can avoid scanning them. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
