<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OMCompilerDoxygen: Two-Level Tree Structure for Fast Pointer Lookup</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OMCompilerDoxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Two-Level Tree Structure for Fast Pointer Lookup </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Boehm-Demers-Weiser conservative Garbage Collector uses a 2-level tree data structure to aid in fast pointer identification. This data structure is described in a bit more detail here, since</p>
<ol type="1">
<li>Variations of the data structure are more generally useful.</li>
<li>It appears to be hard to understand by reading the code.</li>
<li>Some other collectors appear to use inferior data structures to solve the same problem.</li>
<li>It is central to fast collector operation. <a class="el" href="../../d8/d4f/class_a.html">A</a> candidate pointer is divided into three sections, the <em>high</em>, <em>middle</em>, and <em>low</em> bits. The exact division between these three groups of bits is dependent on the detailed collector configuration.</li>
</ol>
<p>The high and middle bits are used to look up an entry in the table described here. The resulting table entry consists of either a block descriptor (<code>struct hblkhdr *</code> or <code>hdr *</code>) identifying the layout of objects in the block, or an indication that this address range corresponds to the middle of a large block, together with a hint for locating the actual block descriptor. Such a hint consist of a displacement that can be subtracted from the middle bits of the candidate pointer without leaving the object.</p>
<p>In either case, the block descriptor (<code>struct hblkhdr</code>) refers to a table of object starting addresses (the <code>hb_map</code> field). The starting address table is indexed by the low bits if the candidate pointer. The resulting entry contains a displacement to the beginning of the object, or an indication that this cannot be a valid object pointer. (If all interior pointer are recognized, pointers into large objects are handled specially, as appropriate.)</p>
<h2>The Tree</h2>
<p>The rest of this discussion focuses on the two level data structure used to map the high and middle bits to the block descriptor.</p>
<p>The high bits are used as an index into the <code>GC_top_index</code> (really <code>GC_arrays._top_index</code>) array. Each entry points to a <code>bottom_index</code> data structure. This structure in turn consists mostly of an array <code>index</code> indexed by the middle bits of the candidate pointer. The <code>index</code> array contains the actual <code>hdr</code> pointers.</p>
<p>Thus a pointer lookup consists primarily of a handful of memory references, and can be quite fast:</p>
<ol type="1">
<li>The appropriate <code>bottom_index</code> pointer is looked up in <code>GC_top_index</code>, based on the high bits of the candidate pointer.</li>
<li>The appropriate <code>hdr</code> pointer is looked up in the <code>bottom_index</code> structure, based on the middle bits.</li>
<li>The block layout map pointer is retrieved from the <code>hdr</code> structure. (This memory reference is necessary since we try to share block layout maps.)</li>
<li>The displacement to the beginning of the object is retrieved from the above map.</li>
</ol>
<p>In order to conserve space, not all <code>GC_top_index</code> entries in fact point to distinct <code>bottom_index</code> structures. If no address with the corresponding high bits is part of the heap, then the entry points to <code>GC_all_nils</code>, a single <code>bottom_index</code> structure consisting only of <code>NULL</code> <code>hdr</code> pointers.</p>
<p><code>Bottom_index</code> structures contain slightly more information than just <code>hdr</code> pointers. The <code>asc_link</code> field is used to link all <code>bottom_index</code> structures in ascending order for fast traversal. This list is pointed to be <code>GC_all_bottom_indices</code>. It is maintained with the aid of <code>key</code> field that contains the high bits corresponding to the <code>bottom_index</code>.</p>
<h2>64-bit addresses</h2>
<p>In the case of 64-bit addresses, this picture is complicated slightly by the fact that one of the index structures would have to be huge to cover the entire address space with a two level tree. We deal with this by turning <code>GC_top_index</code> into a chained hash table, instead of a simple array. This adds a <code>hash_link</code> field to the <code>bottom_index</code> structure.</p>
<p>The <em>hash function</em> consists of dropping the high bits. This is cheap to compute, and guarantees that there will be no collisions if the heap is contiguous and not excessively large.</p>
<h2><a class="el" href="../../d8/d4f/class_a.html">A</a> picture</h2>
<p>The following is an <em>ASCII</em> diagram of the data structure used by GC_base (as of GC v3.7, Apr 21, 1994). This was contributed by Dave Barrett.</p>
<pre class="fragment">    63                  LOG_TOP_SZ[11]  LOG_BOTTOM_SZ[10]   LOG_HBLKSIZE[13]
   +------------------+----------------+------------------+------------------+
 p:|                  |   TL_HASH(hi)  |                  |   HBLKDISPL(p)   |
   +------------------+----------------+------------------+------------------+
    \-----------------------HBLKPTR(p)-------------------/
    \------------hi-------------------/
                      \______ ________/ \________ _______/ \________ _______/
                             V                   V                  V
                             |                   |                  |
           GC_top_index[]    |                   |                  |
 ---      +--------------+   |                   |                  |
  ^       |              |   |                   |                  |
  |       |              |   |                   |                  |
 TOP      +--------------+&lt;--+                   |                  |
 _SZ   +-&lt;|      []      | *                     |                  |
(items)|  +--------------+  if 0 &lt; bi&lt; HBLKSIZE  |                  |
  |    |  |              | then large object     |                  |
  |    |  |              | starts at the bi'th   |                  |
  v    |  |              | HBLK before p.        |             i    |
 ---   |  +--------------+                       |          (word-  |
       v                                         |         aligned) |
   bi= |GET_BI(p){-&gt;hash_link}-&gt;key==hi          |                  |
       v                                         |                  |
       |   (bottom_index)  \ scratch_alloc'd     |                  |
       |   ( struct  bi )  / by get_index()      |                  |
 ---   +-&gt;+--------------+                       |                  |
  ^       |              |                       |                  |
  ^       |              |                       |                  |
 BOTTOM   |              |   ha=GET_HDR_ADDR(p)  |                  |
_SZ(items)+--------------+&lt;----------------------+          +-------+
  |   +--&lt;|   index[]    |                                  |
  |   |   +--------------+                      GC_obj_map: v
  |   |   |              |              from      / +-+-+-----+-+-+-+-+  ---
  v   |   |              |              GC_add   &lt; 0| | |     | | | | |   ^
 ---  |   +--------------+             _map_entry \ +-+-+-----+-+-+-+-+   |
      |   |   asc_link   |                          +-+-+-----+-+-+-+-+ MAXOBJSZ
      |   +--------------+                      +--&gt;| | |  j  | | | | |  +1
      |   |     key      |                      |   +-+-+-----+-+-+-+-+   |
      |   +--------------+                      |   +-+-+-----+-+-+-+-+   |
      |   |  hash_link   |                      |   | | |     | | | | |   v
      |   +--------------+                      |   +-+-+-----+-+-+-+-+  ---
      |                                         |   |&lt;--MAX_OFFSET---&gt;|
      |                                         |         (bytes)
HDR(p)| GC_find_header(p)                       |   |&lt;--MAP_ENTRIES--&gt;|
      |                           \ from        |    =HBLKSIZE/WORDSZ
      |    (hdr) (struct hblkhdr) / alloc_hdr() |    (1024 on Alpha)
      +--&gt;+----------------------+              |    (8/16 bits each)
GET_HDR(p)| word   hb_sz (words) |              |
          +----------------------+              |
          | struct hblk *hb_next |              |
          +----------------------+              |
          |mark_proc hb_mark_proc|              |
          +----------------------+              |
          | char * hb_map        |&gt;-------------+
          +----------------------+
          | ushort hb_obj_kind   |
          +----------------------+
          |   hb_last_reclaimed  |
 ---      +----------------------+
  ^       |                      |
 MARK_BITS|       hb_marks[]     |  * if hdr is free, hb_sz is the size of
_SZ(words)|                      |  a heap chunk (struct hblk) of at least
  v       |                      |  MININCR*HBLKSIZE bytes (below),
 ---      +----------------------+  otherwise, size of each object in chunk.
</pre><p>Dynamic data structures above are interleaved throughout the heap in blocks of size <code>MININCR * HBLKSIZE</code> bytes as done by <code>gc_scratch_alloc</code> which cannot be freed; free lists are used (e.g. <code>alloc_hdr</code>). <code>HBLK</code>'s below are collected.</p>
<pre class="fragment">              (struct hblk)                                  HDR_BYTES
 ---      +----------------------+ &lt; HBLKSIZE  ---            (bytes)
  ^       +-----hb_body----------+ (and WORDSZ) ^         ---   ---
  |       |                      |   aligned    |          ^     ^
  |       |                      |              |        hb_sz   |
  |       |                      |              |       (words)  |
  |       |      Object 0        |              |          |     |
  |       |                      |            i |(word-    v     |
  |       + - - - - - - - - - - -+ ---   (bytes)|aligned) ---    |
  |       |                      |  ^           |          ^     |
  |       |                      |  j (words)   |          |     |
  n *     |      Object 1        |  v           v        hb_sz BODY_SZ
 HBLKSIZE |                      |---------------          |   (words)
 (bytes)  |                      |                         v   MAX_OFFSET
  |       + - - - - - - - - - - -+                        ---  (bytes)
  |       |                      | !ALL_INTERIOR_POINTERS  ^     |
  |       |                      | sets j only for       hb_sz   |
  |       |      Object N        | valid object offsets.   |     |
  v       |                      | All objects WORDSZ      v     v
 ---      +----------------------+ aligned.               ---   ---</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
